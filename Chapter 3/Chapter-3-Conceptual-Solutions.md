# Chapter-3-Conceptual-Solutions

## Questions And Answers
Exercise 3.2: Is the MDP framework adequate to usefully represent all goal-directed learning tasks? Can you think of any clear exceptions?

The MDP framework assumes the Markov property, namely that the state includes information about all aspects of the past agent-environment interaction that make a difference for the future.  An MDP framework is not really appropriate for a goal-directed learning task for which this Markov property is not true (e.g., where path dependency in arriving at a state also makes a difference for the future).

Another situation that might be difficult for an MDP framework would be if the goal-directed learning task had multiple goals it was trying to accomplish.  In this case, instead of the reward being being a single scalar, the reward would be a multi-component vector; in this case, the reinforcement learning scheme would probably have to invoke some additional constraint in order to perform the optimization.

Exercise 3.6: Suppose you treated pole-balancing as an episodic task but also used discounting, with all rewards zero except for -1 upon failure. What then would the return be at each time? How does this return differ from that in the discounted, continuing formulation of this task?

As discussed in the text, in the discounted, continuing task formulation, the return at each time would be related to ![$-\gamma^K$](https://render.githubusercontent.com/render/math?math=%24-%5Cgamma%5EK%24), where ![$K$](https://render.githubusercontent.com/render/math?math=%24K%24) is the number of time steps before failure.  In the discounted, episodic task formulation, the return at each time is still related to ![$-\gamma^K$](https://render.githubusercontent.com/render/math?math=%24-%5Cgamma%5EK%24), but ![$K$](https://render.githubusercontent.com/render/math?math=%24K%24) is constrained to be less than or equal to the total number of time steps of an episode ![$T$](https://render.githubusercontent.com/render/math?math=%24T%24).  Thus, the main difference is that the episodic task has a strict cap on the maximum return (which is related to ![$-\gamma^T$](https://render.githubusercontent.com/render/math?math=%24-%5Cgamma%5ET%24)).

Exercise 3.7: Imagine that you are designing a robot to run a maze. You decide to give it a reward of +1 for escaping from the maze and a reward of zero at all other times. The task seems to break down naturally into episodes--the successive runs through the maze--so you decide to treat it as an episodic task, where the goal is to maximize expected total reward (3.7). After running the learning agent for a while, you find that it is showing no improvement in escaping from the maze. What is going wrong? Have you effectively communicated to the agent what you want it to achieve?

Treating the task as episodic with a reward of +1 for escaping the maze and a reward of 0 at all other times means that the robot experiences no penalty for exploring the maze without escape. As a result, the robot may learn to explore the maze until the number of time steps in an episode elapses.  An alternative treatment which may improve performance is to treat the task as episodic but to penalize the robot (e.g., prescribing a negative reward) for each time step spent in the maze without escape.

Exercise 3.8: Suppose ![$\gamma = 0.5$](https://render.githubusercontent.com/render/math?math=%24%5Cgamma%20%3D%200.5%24) and the following sequence of rewards is received: ![$R_1 = -1, R_2 = 2, R_3 = 6, R_4 = 3, R_5 = 2$](https://render.githubusercontent.com/render/math?math=%24R_1%20%3D%20-1%2C%20R_2%20%3D%202%2C%20R_3%20%3D%206%2C%20R_4%20%3D%203%2C%20R_5%20%3D%202%24), with ![$T = 5$](https://render.githubusercontent.com/render/math?math=%24T%20%3D%205%24). What are ![$G_0, G_1, \cdots, G_5$](https://render.githubusercontent.com/render/math?math=%24G_0%2C%20G_1%2C%20%5Ccdots%2C%20G_5%24)? Hint: Work backwards.

Using Equation 3.9 from the text (![$G_t = R_{t+1} + \gamma G_{t+1}$](https://render.githubusercontent.com/render/math?math=%24G_t%20%3D%20R_%7Bt%2B1%7D%20%2B%20%5Cgamma%20G_%7Bt%2B1%7D%24)) with ![$G_T = G_5 = 0$](https://render.githubusercontent.com/render/math?math=%24G_T%20%3D%20G_5%20%3D%200%24),

![\begin{align*} G_5 &= 0 \\ G_4 &= R_5 + \gamma G_5 = 2 + (0.5)(0) = 2 \\ G_3 &= R_4 + \gamma G_4 = 3 + (0.5)(2) = 4 \\ G_2 &= R_3 + \gamma G_3 = 6 + (0.5)(4) = 8 \\ G_1 &= R_2 + \gamma G_2 = 2 + (0.5)(8) = 6 \\ G_0 &= R_1 + \gamma G_1 = -1 + (0.5)(6) = 2. \end{align*}](https://render.githubusercontent.com/render/math?math=%5Cbegin%7Balign*%7D%20G_5%20%26%3D%200%20%5C%5C%20G_4%20%26%3D%20R_5%20%2B%20%5Cgamma%20G_5%20%3D%202%20%2B%20(0.5)(0)%20%3D%202%20%5C%5C%20G_3%20%26%3D%20R_4%20%2B%20%5Cgamma%20G_4%20%3D%203%20%2B%20(0.5)(2)%20%3D%204%20%5C%5C%20G_2%20%26%3D%20R_3%20%2B%20%5Cgamma%20G_3%20%3D%206%20%2B%20(0.5)(4)%20%3D%208%20%5C%5C%20G_1%20%26%3D%20R_2%20%2B%20%5Cgamma%20G_2%20%3D%202%20%2B%20(0.5)(8)%20%3D%206%20%5C%5C%20G_0%20%26%3D%20R_1%20%2B%20%5Cgamma%20G_1%20%3D%20-1%20%2B%20(0.5)(6)%20%3D%202.%20%5Cend%7Balign*%7D)
